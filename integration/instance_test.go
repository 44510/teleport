package integration

import (
	"context"
	"embed"
	"net"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/gravitational/teleport"
	"github.com/gravitational/teleport/api/types"
	"github.com/gravitational/teleport/lib"
	"github.com/gravitational/teleport/lib/auth"
	"github.com/gravitational/teleport/lib/backend"
	"github.com/gravitational/teleport/lib/defaults"
	"github.com/gravitational/teleport/lib/service"
	"github.com/gravitational/teleport/lib/service/servicecfg"
	"github.com/gravitational/teleport/lib/services"
	"github.com/gravitational/teleport/lib/utils"
	"github.com/gravitational/trace"
	"github.com/stretchr/testify/require"
)

//go:embed instance-assets
var instanceAssets embed.FS

// writeInstanceAssets writes the contents of the instance assets embedded fs to the
// specified target "real" directory.
func writeInstanceAssets(src string, dst string) error {
	entries, err := instanceAssets.ReadDir(src)
	if err != nil {
		return trace.Wrap(err)
	}

	if err := os.MkdirAll(dst, teleport.PrivateDirMode); err != nil {
		return trace.Wrap(err)
	}

	for _, entry := range entries {
		if entry.IsDir() {
			if err := writeInstanceAssets(filepath.Join(src, entry.Name()), filepath.Join(dst, entry.Name())); err != nil {
				return trace.Wrap(err)
			}
			continue
		}

		data, err := instanceAssets.ReadFile(filepath.Join(src, entry.Name()))
		if err != nil {
			return trace.Wrap(err)
		}

		if err := os.WriteFile(filepath.Join(dst, entry.Name()), data, teleport.PrivateDirMode); err != nil {
			return trace.Wrap(err)
		}
	}

	return nil
}

func getFreeListenAddr() (string, error) {
	l, err := net.Listen("tcp", "localhost:0")
	if err != nil {
		return "", trace.Wrap(err)
	}

	defer l.Close()
	return l.Addr().String(), nil
}

// TestInstanceCertReissue tests the reissuance of an instance certificate when
// the instance has malformed system roles using pre-constructed data directories
// generated by an older teleport version that permitted token mix-and-match.
func TestInstanceCertReissue(t *testing.T) {
	lib.SetInsecureDevMode(true)
	defer lib.SetInsecureDevMode(false)

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Create temporary directories for the auth and agent data directories.
	authDir, agentDir := t.TempDir(), t.TempDir()

	// Write the instance assets to the temporary directories to set up pre-existing
	// state for our teleport instances to use.
	require.NoError(t, writeInstanceAssets("instance-assets/auth", authDir))
	require.NoError(t, writeInstanceAssets("instance-assets/agent", agentDir))

	time.Sleep(time.Second * 30)

	proxyAddr, err := getFreeListenAddr()
	require.NoError(t, err)

	authAddr, err := getFreeListenAddr()
	require.NoError(t, err)

	authCfg := servicecfg.MakeDefaultConfig()
	authCfg.Version = defaults.TeleportConfigVersionV3
	authCfg.DataDir = authDir
	require.NoError(t, authCfg.SetAuthServerAddresses([]utils.NetAddr{
		{
			AddrNetwork: "tcp",
			Addr:        authAddr,
		},
	}))
	authCfg.Auth.Enabled = true
	// ensure auth server is using the pre-constructed sqlite db
	authCfg.Auth.StorageConfig.Params = backend.Params{defaults.BackendPath: filepath.Join(authDir, defaults.BackendDir)}
	authCfg.Auth.ClusterName, err = services.NewClusterNameWithRandomID(types.ClusterNameSpecV2{
		ClusterName: "auth-server",
	})
	authCfg.Auth.ListenAddr.Addr = authAddr
	authCfg.Auth.NetworkingConfig.SetProxyListenerMode(types.ProxyListenerMode_Multiplex)

	authCfg.Proxy.Enabled = true
	authCfg.Proxy.DisableWebService = true
	authCfg.Proxy.DisableWebInterface = true
	authCfg.Proxy.WebAddr.Addr = proxyAddr

	authCfg.SSH.Enabled = true
	authCfg.SSH.Addr.Addr = "localhost:0"

	var authRunErrCh = make(chan error, 1)
	var authIdentitiesCh = make(chan *auth.Identity, 2)
	go func() {
		authRunErrCh <- service.Run(ctx, *authCfg, func(cfg *servicecfg.Config) (service.Process, error) {
			proc, err := service.NewTeleport(cfg)
			if err != nil {
				return nil, trace.Wrap(err)
			}

			identity, err := proc.GetIdentity(types.RoleInstance)
			if err != nil {
				proc.Close()
				return nil, trace.Wrap(err)
			}

			select {
			case authIdentitiesCh <- identity:
			default:
			}

			return proc, nil
		})
	}()

	timeout := time.After(time.Second * 30)
	select {
	case <-timeout:
		t.Fatal("timed out waiting for first auth identity")
	case identity := <-authIdentitiesCh:
		require.ElementsMatch(t, []string{string(types.RoleAuth), string(types.RoleProxy)}, identity.SystemRoles)
	}

	select {
	case <-timeout:
		t.Fatal("timed out waiting for second auth identity")
	case identity := <-authIdentitiesCh:
		require.ElementsMatch(t, []string{string(types.RoleAuth), string(types.RoleProxy), string(types.RoleNode)}, identity.SystemRoles)
	}

	agentCfg := servicecfg.MakeDefaultConfig()
	agentCfg.Version = defaults.TeleportConfigVersionV3
	agentCfg.DataDir = agentDir
	agentCfg.ProxyServer = utils.NetAddr{
		AddrNetwork: "tcp",
		Addr:        proxyAddr,
	}

	agentCfg.Auth.Enabled = false
	agentCfg.Proxy.Enabled = false
	agentCfg.SSH.Enabled = true
	agentCfg.WindowsDesktop.Enabled = true

	var agentRunErrCh = make(chan error, 1)
	var agentIdentitiesCh = make(chan *auth.Identity, 2)
	go func() {
		agentRunErrCh <- service.Run(ctx, *agentCfg, func(cfg *servicecfg.Config) (service.Process, error) {
			proc, err := service.NewTeleport(cfg)
			if err != nil {
				return nil, trace.Wrap(err)
			}

			identity, err := proc.GetIdentity(types.RoleInstance)
			if err != nil {
				proc.Close()
				return nil, trace.Wrap(err)
			}

			select {
			case agentIdentitiesCh <- identity:
			default:
			}

			return proc, nil
		})
	}()

	timeout = time.After(time.Second * 30)
	select {
	case <-timeout:
		t.Fatal("timed out waiting for first agent identity")
	case identity := <-agentIdentitiesCh:
		require.ElementsMatch(t, []string{string(types.RoleNode)}, identity.SystemRoles)
	}

	select {
	case <-timeout:
		t.Fatal("timed out waiting for second agent identity")
	case identity := <-agentIdentitiesCh:
		require.ElementsMatch(t, []string{string(types.RoleNode), string(types.RoleWindowsDesktop)}, identity.SystemRoles)
	}
}
