---
title: Deploying Machine ID
description: How to deploy Machine ID for your environment
---

(!docs/pages/includes/machine-id/v2-config-warning.mdx!)

This guide covers background information necessary to understand the operation
of Machine ID and covers specific guidance for deployment environments.

For a quick overview of Machine ID, see the [Quick Start Guide](../getting-started.mdx).

## Background

Teleport Machine ID provides authentication for machine access to Teleport. This
allows unattended machines (e.g CI/CD workflows) to access resources protected
by Teleport and configure Teleport itself. By using Machine ID, you benefit from
the same rich auditing, fine-grained access control and short-lived certificates
that Teleport provides for human access.

Machine ID operates through the `tbot` agent. This agent outputs artifacts such
as certificates and configuration files to destinations (such as a filesystem
directory). These artifacts can then be read by other tools from the destination
and used to access Teleport resources.

`tbot` authenticates to the Teleport Cluster using a **join token** which is
associated with a **Bot User**. The **Bot User** is assigned a **Bot Role**
which grants it the ability to generate certificates for a specified set of
roles through a process known as role impersonation. This means that credentials
output by Machine ID can be limited to a specific Teleport role - providing a
basis for implementing the principle of least access.

## Configuring Machine ID for your platform

### CI/CD

Machine ID integrates with a number of common CI/CD platforms to provide
secure and fine-grained joining for your bot to your Teleport Cluster.

Typically, on CI/CD platforms, `tbot` should be run in one-shot mode at the
start of a CI/CD pipeline and within the run environment.

#### GitLab

TODO

#### GitHub

TODO

#### CircleCI

TODO

#### Jenkins

TODO

#### Other platforms

Even if Machine ID does not have a distinct integration with your CI/CD
platform, deployment is often still possible.

For platforms where you manage the deployment of the CI/CD runners, follow the
guidance for a Linux host where `tbot` runs as a background service.

The output destination must then be made accessible to the CI/CD run
environment. On non-containerised systems, this can be achieved using Linux
filesystem permissions, on containerised systems, this can be achieved by
mounting the destination directory from the host in to the CI/CD run container.

For platforms where you do not manage the CI/CD runners, deployment of
Machine ID can be more challenging. This is because the `token` join method
relies on persistent state for `tbot` which conflicts with the commonly
ephemeral nature of CI/CD run environments.

### Linux hosts

#### Generic

TODO: Mention the limitations of the `token` join method in depth
TODO: - Single use
TODO: - Requires persistence of the bot state
TODO: - One to one link between Bot User to tbot state

#### GCP

TODO

#### Azure

TODO

#### AWS

TODO

## Configuring outputs

`tbot` is configured with a series of outputs. Each output specifies a
destination that any artifacts should be written to and specifies the type
of the output. When one-shot mode is enabled, `tbot` will generate each of the
configured outputs and then exit.

```yaml
outputs:
- type: identity
  roles: ["editor"]
  destination:
    type: directory
    path: /opt/machine-id
```

This example output configuration writes an output of type `identity` to the
directory `/opt/machine-id`.

### SSH

TODO

### Kubernetes Access

TODO

### Application Access

TODO

### Database Access

TODO

### Managing Teleport with `tctl`

`tctl` is the Teleport Cluster management tool. When used in combination with
simple scripting languages (e.g `bash`) and Machine ID for authentication, it is
possible to build unattended automations to manage your Teleport cluster.

To produce credentials to use with `tctl`, create an identity output. This
will create an `identity` artifact which contains the necessary credentials
for `tctl` to authenticate to your Teleport Auth Server.

```yaml
outputs:
- type: identity
  destination:
    type: directory
    path: ./my-output
```

The path to this identity file can then be specified to `tctl` using the `-i`
flag, e.g

```code
$ tctl -i ./my-output/identity --auth-server example.teleport.sh:443 nodes ls
```

### Managing Teleport with the Teleport API Client

For more advanced custom automations, the Teleport API client can be used to
interact with your Teleport cluster.

To produce credentials to use with the Teleport API client, create an identity
output. This will create an `identity` artifact which contains the necessary
credentials for the Teleport API client to authenticate to your Teleport Auth
Server.

```yaml
outputs:
- type: identity
  destination:
    type: directory
    path: ./my-output
```

The path to this identity file can then be provided to the Teleport API client:

```go
package main

import (
	"context"
	"log"

	"github.com/gravitational/teleport/api/client"
)

func main() {
	ctx := context.Background()
	clt, err := client.New(ctx, client.Config{
		Addrs: []string{
			"example.teleport.sh:443",
 		},
		Credentials: []client.Credentials{
			client.LoadIdentityFile("./my-output/identity"),
		},
	})
}
```

<Notice type="warning">
`LoadIdentityFile` does not handle reloading the short-lived identity file
automatically. If your custom automation is likely to run for a long period,
ensure you recreate the client regularly to use the latest identity file that
`tbot` has written.
</Notice>

More advice on using the Teleport API client can be found in the
[Teleport API documentation](../../api/introduction.mdx).

### SSH Host Certificates

TODO

## Next Steps

- [Configuration Reference](../reference/configuration.mdx): A full description
  of all Machine ID configuration options.
- [Architecture](../architecture.mdx): A technical overview of how Machine ID
  works