---
authors: Nic Klaassen (nic@goteleport.com), Rafał Cieślak (rafal.cieslak@goteleport.com)
state: draft
---

# RFD 163 - Teleport VNet

## What

Teleport VNet creates a virtual IP subnet with DNS that automatically proxies
TCP connections to Teleport apps over fully authenticated tunnels.
After logging in once, users will be able to connect to all of their Teleport
applications at a URL or IP address with zero extra steps.
Scripts and software applications will be able to connect to Teleport-protected
applications as if they were running on the local network without any extra
configuration or even having to know that Teleport is involved.

## Why

Teleport App Access has a pretty good UX for HTTP apps accessed through a web
browser, but the experience isn't up to par outside of the browser.

Today, Teleport users have two choices for accessing Teleport-protected apps and
APIs with non-browser clients:

1. Use a custom TLS certificate and private key with the client and connect to a
   subdomain of the Teleport proxy, e.g. `curl --cert /Users/nic/.tsh/keys/one.teletest.private/nic-app/one.teletest.private/dumper-x509.pem --key /Users/nic/.tsh/keys/one.teletest.private/nic`.
2. Proxy the app to a TCP listener on localhost, e.g. `tsh proxy app dumper --port 8888 & curl 127.0.0.1:8888`

Both of these methods are fairly cumbersome, inflexible, and they may not even
be possible with some clients, especially when needing to connect to many apps
or using custom scripts or software that expects to be able to find these apps
at a regular-old DNS address.
Teleport VNet removes the need for manual management of client certs or tunnels.

## Details

Teleport VNet will run in the background on end-user devices (laptops, workstations).
It will be integrated into Teleport Connect, and may also be available as a
`tsh` command (TBD).

It works by creating a TUN virtual network interface and configuring an IP route
to send all outgoing IP packets to that interface.
In the background, Teleport VNET will handle all incoming TCP connections to the
TUN interface and proxy them to Teleport apps over authenticated tunnels, in
much the same way that the `tsh proxy app` command works today.

The VNET will also host a local DNS service serving custom domain names for all
Teleport-protected apps, and directing the DNS queries for each app to an IP
address in the VNet's virtual IP range assigned to the app in question.

### Domain name assignment

The default VNet domain name for each app will be `<app>.<proxy-address>.internal`.
For an app named `api` in a Teleport cluster at `teleport.example.com` this
would look like `api.teleport.example.com.internal`.

There will be two ways to override this.

The `spec.public_addr` field of the app resource already overrides the public
address of the app for web and TCP app access.
If the `public_addr` is set for an app, that address will be used in VNET, with
`.internal` appended.
An app with `public_addr: api.example.com`, would be accessed at
`api.example.com.internal` in VNet.

To override the address just for VNet, a new `spec.vnet_addr` field will be
added on app resources.
When this is used, the `internal` suffix will NOT automatically be added.
An app with `vnet_addr: api.example.com` would be accessed at `api.example.com`
in VNet.
If `spec.vnet_addr` is not set it will default to `spec.public_addr`, which in
turn defaults to `<app-name>.<proxy-public-address>`.

Because we will use split DNS to configure VNet as a DNS server, if the
`vnet_addr` is NOT suffixed with `<proxy-public-address>.internal` the Teleport
admin will need to statically configure a custom DNS zone in the cluster, see
[custom DNS zones](#custom-dns-zones).

#### Leaf and parallel clusters

A user may be logged in to multiple Teleport Clusters at once, those may be leaf
clusters or completely separate clusters.
Each cluster may include apps with identical names, so including the full proxy
address avoids assigning domain names that will conflict under these conditions.

If the user is accessing app in a leaf Teleport cluster via a root cluster they
have logged in to, the VNet domain name will use the address of the leaf proxy.
For an app named `api` in a Teleport cluster at `leaf.example.com` this
would look like `api.leaf.example.com.internal`
This differs from non-VNet app access where both would use the same domain name
`api.teleport.example.com` because in VNet we cannot use a client certificate or
a cookie to differentiate.

#### Why `.internal`

Today, by default, apps are publicly reachable at `<app>.<proxy-domain-name>`,
e.g. `api.teleport.example.com`.
That is the URL you would go to in the browser to reach an HTTP app through
Teleport, and it is the same for TCP app access.
The domain name is expected to resolve to the public address of the Teleport Proxy.
The app at this address is protected by TLS terminated at the Teleport Proxy,
which usually has a publicly trusted wildcard TLS certificate for
`*.teleport.example.com`.

Teleport VNet will avoid overriding or conflicting with this domain name for a
few reasons:

1. To avoid incidentally breaking the currently supported flow if something goes
   wrong with the VNet or it is just not running locally.
1. While the tunnels VNet creates in the background will be authenticated by
   mTLS, local clients will see it as an unauthenticated TCP endpoint.
   When users connect to this domain name in the browser, we still want them to
   see that it is protected by TLS.

To break the conflict we can add a TLD/suffix to the domain name used in VNet.
ICANN has recently assigned the `.internal` TLD for internal or private use
applications so it seems like the appropriate choice.
https://itp.cdn.icann.org/en/files/root-system/identification-tld-private-use-24-01-2024-en.pdf

### Custom DNS zones

Some users may want to use custom domain names for their apps in VNet.
Maybe they currently access an app on their VPN at `api.example.private` and
they want to migrate off their VPN to Teleport without changing all their
software and scripts that currently reference that name.

To do this they can set the `spec.vnet_addr` field in the app resource to
`api.example.private`, but VNet will also need to know to configure itself as
the DNS server for `*.example.private`, and what to do with other DNS requests
matching `*.example.private` with no matching Teleport app.

To accomodate this the Teleport admin can configure a custom DNS zone
cluster-wide with a new `vnet` Teleport resource:

```yaml
version: v1
kind: vnet
metadata:
  name: vnet
spec:
  custom_dns_zones:
  - suffix: .example.private
    upstream_nameservers:
    - 1.2.3.4
    - 4.5.6.7
  - suffix: .test.private
```

In this example, whenever the user is logged in to the cluster where this `vnet`
configuration resource is present, VNet will install itself as the DNS
nameserver for `*.example.private` and `*.test.private`.

### DNS queries and IP address assignment

This design tries to avoid making the VNet client maintain an up-to-date list of
all apps in all clusters with assigned IPs.
To that end, IPs will be dynamically assigned to apps the first time DNS is
queried for that app.

The VNet process will regulary poll for the currently logged-in root and leaf
clusters to discover their proxy addresses and
[custom DNS zones](#custom-dns-zones).
When any DNS query comes in it will:

1. If an IP address is already assigned to the full queried name, an
   authoritative answer will be sent with that IP.
1. If the name matches any `<app-name>.<proxy-address>.internal` we will query
   the cluster to see if the app actually exists.
    1. If the app does not exist, the DNS server will response with an
       authoritative non-answer to indicate this is not a valid name.
    1. If the app does exist, a free IP will be assigned to it and it will be
       returned in an authoritative answer.
1. If the name matches `*.<custom-dns-zone>`:
    1. VNet will determine which cluster(s) the matching custom DNS zone is in from
       its local state.
    1. VNet will query the cluster(s) apps to see if any have a `spec.vnet_addr`
       matching the full name. This will use a predicate expression to do the
       filtering server-side and avoid listing all apps.
    1. If a match is found a free IP will be assigned to that app and it will be
       returned in an authoritative answer.
    1. If no match is found and the zone has no `upstream_nameservers` configured,
       no answer will be sent.
    1. The full DNS query will be forwarded to one of the `upstream_nameservers`,
       selected randomly from the list, and any upstream response will be
       returned to the client verbatim.
       We may implement caching of upstream responses, but hopefully the
       downstream resolver will do its own caching.
1. If the name did not match any `<proxy-address>.internal` or custom DNS zone,
   no response will be sent.

TODO: sequence diagram

### IP range

By default IPs will be assigned from the carrier-grade NAT range 100.64.0.0/10
Since VNet IPs will only be used locally on end user machines this range is
quite unlikely to conflict with any valid public or private IP addresses, unless
another VPN client is being used that happens to use the same range.
For example, tailscale also uses this range.
This range can be overriden with a cluster-wide configuration.

```yaml
version: v1
kind: vnet
metadata:
  name: vnet
spec:
  cidr_range: 100.64.0.0/10
```

### Host configuration

Vnet will need to create a TUN interface, assign an IP to it, and modify the
routing table.

To create the TUN interface we will import `golang.zx2c4.com/wireguard/tun`
which provides cross-platform methods for creating TUN interfaces and reading
from + writing them.
It supports MacOS, Windows, and Linux.

On MacOS, to assign an IP address to the interface, we will use `os/exec` to run
the `ifconfig` command:

```shell
ifconfig utun4 100.64.0.1 100.64.0.1 up
```

On MacOS, to assign an IP route to use the TUN interface, we will use `os/exec`
to run the `route` command:

```shell
route add -net 100.64.0.0/10 -interface utun4
```

All system configuration must run as a privileged user/root.
In the first version we will use an Applescript wrapper to call a child process
as root.
The child admin process will still be the `tsh` binary, just called with
arguments to do the host setup.
See the UX section for more details on the admin process.

The first version of VNet will only support MacOS so this is written with that
in mind, but we can implement this in a similar way for Windows and Linux.

### Security

### UX

VNet is available in both tsh and Teleport Connect. This section focuses mostly on VNet integration
in Teleport Connect, with a short subsection on VNet in tsh at the end.

Attempting to connect to a TCP app opens the VNet tab instead. When the VNet app is opened this way,
it gives the user an option to either start VNet or open a standard local proxy instead.

Web apps continue to launch through the proxy service. The three dot menu next to web apps gains a
new action called "Open through VNet". If VNet is running, it opens the app VNet address in the
browser. If VNet is not running, it opens the VNet tab saying "You can open dumper and other apps
through VNet". After VNet starts, the message becaumes "dumper is available at
dumper.teleport.private" with either a link or a button to open the address in the browser.

TODO: Dedicated button in top left with status indicator.

#### Lifecycle

The first version of VNet integration in Connect is going to behave similarly to Connect My
Computer. After the user starts VNet and until they explicitly stop it, VNet will start
automatically when launching the app. It will prompt for password for admin privileges through
osascript on each start. This requires the given system user to be an admin, disqualifying cases
where the user is just a standard macOS account.

Unfortunately, [Touch ID prompts are reserved for Apple
clients](https://forums.developer.apple.com/forums/thread/701118?answerId=705661022#705661022). We
assume that typically the user is going to start VNet and then just leave it running, somewhat
negating the downside of having to enter credentials on each start.

##### Considered alternatives

Tying the lifecycle of VNet to the lifecycle of Connect gets us past the problem of needing root
privileges to create a TUN device and lets us focus on validating VNet as a tool. However, there is
a couple of different approaches we could take which offer better UX at the cost of development
time.

###### Launch VNet on system start

Doing so would require some kind of persistent UI that is also launched on system start, think an
app in the Menu Bar. The UI would need to enable the user to manage the state of VNet and provide a
way to refresh expired certs. Connect could support headless mode where it does not open the main
window automatically and instead launches a separate frontend app which handles relogin.

###### Ask for admin privileges just once

The recommended way for an unprivileged app to use privileged APIs is to use
[`SMAppService`](https://developer.apple.com/documentation/servicemanagement/smappservice).
`SMAppService` allows the unprivileged app to add a privileged launch daemon to launchd. That daemon can be
launched on demand from the unprivileged, do its work and then shut down, without having to enter
credentials each time. The daemon lives in the app bundle and is automatically cleaned up when the
user removes `Teleport Connect.app`.

With `SMAppService`, there are two main problems to figure out:

* How to call this Swift API in the first place.
  * Do we need to build our own simple app just to register a daemon for the main app?
* How to securely communicate with the daemon.
  * Communication is typically done through XPC, as shown in [the example
    app](https://developer.apple.com/documentation/servicemanagement/updating-your-app-package-installer-to-use-the-new-service-management-api).
    How viable it is to use it from Go?
  * Secure communication can be achieved through [environment
    constraints](https://developer.apple.com/videos/play/wwdc2023/10266/) by enforcing that only
    programs signed by us can interact with the daemon.
  * Is gRPC a viable alternative here?

The main benefit of using `SMAppService` is the aforementioned single prompt for root privileges.
It's also possible that VNet could be made to work in an environment where the system user is just a
standard user by delegating daemon registration to an admin. `SMAppService` could be used from
within tsh as well, but the user would need to use the signed version of tsh.

Given that using `SMAppService` is much more complex than calling osascript, implementing
`SMAppService` is a good candidate for a future version of VNet.

#### tsh integration

TODO

### Proto Specification

### Backward Compatibility

### Audit Events

### Observability

### Product Usage

### Test Plan
